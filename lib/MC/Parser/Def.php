<?php

declare(strict_types = 1);

namespace MC\Parser;

use MC\Parser;
use MC\Parser\Token\Group;

/**
 * The root class of all instances generated by MC_Parser when defining a grammar.
 */
abstract class Def
{
    /** @var null|string */
    public $name;

    /** @var bool */
    public $suppress = false;

    /**
     * Parse a string, and return the result or throw a parser exception.
     *
     * @throws ParseError
     */
    public function parse(string $str): Token
    {
        $str = ltrim($str);

        [$loc, $tok] = $this->parsePart($str, 0);
        if ($loc !== strlen($str)) {
            throw new ParseError('An error occurred: "'.substr($str, $loc).'"', $str, $loc);
        }

        return $tok;
    }

    /**
     * Parse a string, cleaning up whitespace when we're done.
     *
     * @return array A two-item array of the string location where parsing stopped, and the MC_Token instance that matches the grammar conditions
     *
     * @throws ParseError
     */
    public function parsePart(string $str, int $loc): array
    {
        [$loc, $tok] = $this->_parse($str, $loc);

        $char = @$str[$loc++];
        while (('' !== $char) && Parser::isWhitespace($char)) {
            $char = @$str[$loc++];
        }
        --$loc;

        return [$loc, $tok];
    }

    /**
     * Each definition type should implement their own _parse() function that tests a string.
     *
     * @param string $str the string to parse
     * @param int    $loc the index to start parsing
     *
     * @return array A two-item array of the string location where parsing stopped, and the MC_Token instance that matches the grammar conditions
     *
     * @throws ParseError
     */
    abstract public function _parse(string $str, int $loc): array;

    /**
     * Each definition type should have some way of giving itself a name if the user didn't provide one.
     */
    abstract public function _name(): string;

    /**
     * Return the user-provided name, if given, or the generated one otherwise.
     */
    public function getName(): string
    {
        return $this->name ?? $this->_name();
    }

    /**
     * Give this grammar def a name in the results.
     */
    public function name(string $name): self
    {
        $this->name = $name;

        return $this;
    }

    /**
     * Toggle suppressing the token from the results.
     */
    public function suppress(): self
    {
        $this->suppress = true;

        return $this;
    }

    /**
     * Return a token instance, copying over this Def's name and flagging suppression.
     *
     * @param mixed $value
     *
     * @return null|Token the new token, or null if the token should be suppressed
     */
    public function token($value): ?Token
    {
        if ($this->suppress) {
            return null;
        }

        return new Token($value, $this->name);
    }

    /**
     * Return a token group (a token that can contain subtokens), copying over this Def's name
     * token groups cannot be suppressed.
     */
    public function tokenGroup(): Group
    {
        return new Group($this->name);
    }
}
