<?php

namespace MC\Parser;

use MC\Parser;
use MC\Parser\Token\Group;

/**
 * The root class of all instances generated by MC_Parser when defining a grammar.
 */
abstract class Def
{
    public $name;
    public $suppress = false;

    /**
     * Parse a string, and return the result or throw a parser exception.
     *
     * @param string $str
     *
     * @throws ParseError
     *
     * @return Token
     */
    public function parse($str)
    {
        $str = ltrim($str);

        list($loc, $tok) = $this->parsePart($str, 0);
        if ($loc !== strlen($str)) {
            throw new ParseError('An error occurred: "'.substr($str, $loc).'"', $str, $loc);
        }

        return $tok;
    }

    /**
     * Parse a string, cleaning up whitespace when we're done.
     *
     * @param string $str
     * @param int    $loc
     *
     * @throws ParseError
     *
     * @return array A two-item array of the string location where parsing stopped, and the MC_Token instance that matches the grammar conditions
     */
    public function parsePart($str, $loc)
    {
        list($loc, $tok) = $this->_parse($str, $loc);

        $char = @$str[$loc++];
        while ($char && Parser::isWhitespace($char)) {
            $char = @$str[$loc++];
        }
        --$loc;

        return [$loc, $tok];
    }

    /**
     * Each definition type should implement their own _parse() function that tests a string.
     *
     * @param string $str the string to parse
     * @param int    $loc the index to start parsing
     *
     * @throws ParseError
     *
     * @return array A two-item array of the string location where parsing stopped, and the MC_Token instance that matches the grammar conditions
     */
    abstract public function _parse($str, $loc);

    /**
     * Each definition type should have some way of giving itself a name if the user didn't provide one.
     *
     * @return string
     */
    abstract public function _name();

    /**
     * Return the user-provided name, if given, or the generated one otherwise.
     */
    public function getName()
    {
        if (null !== $this->name) {
            return $this->name;
        }

        return $this->_name();
    }

    /**
     * Give this grammar def a name in the results.
     *
     * @param string $name
     *
     * @return Def $this - chainable method
     */
    public function name($name)
    {
        $this->name = $name;

        return $this;
    }

    /**
     * Toggle suppressing the token from the results.
     */
    public function suppress()
    {
        $this->suppress = true;

        return $this;
    }

    /**
     * Return a token instance, copying over this Def's name and flagging suppression.
     *
     * @param mixed $value
     *
     * @return null|Token the new token, or null if the token should be suppressed
     */
    public function token($value)
    {
        if ($this->suppress) {
            return null;
        }

        return new Token($value, $this->name);
    }

    /**
     * Return a token group (a token that can contain subtokens), copying over this Def's name
     * token groups cannot be suppressed.
     *
     * @return Group
     */
    public function tokenGroup()
    {
        return new Group($this->name);
    }
}
